**1**
A.tune()不是虚函数，不可重写覆盖
B.这是重写隐藏
C.tune()函数不是虚函数，因为早绑定导致实际调用的还是Instrument的tune()
D.该对象不仅包含一个4字节的int，还包含一个4字节的指向虚函数表的虚指针
**2**
B.虚析构函数必须定义函数体
C.就算用final修饰了也依然会有虚函数表，只是在使用final关键字后后续的派生类无法对该版本的虚函数进行重写覆盖
D.Base的析构函数是虚的，所以调用的是Derived的析构函数
**3**
A.此为重写覆盖
B.play()不是虚函数，final关键字施加于函数声明或定义时需要确保该函数必须是虚函数
C.想要通过基类指针调用派生类的函数，首先基类要有相应类型的虚函数，而StringInstrument中没有tune()所对应的虚函数
**4**
A.可能是析构函数为虚函数
B.除非将所有除纯虚析构函数之外的所有纯虚函数进行重写覆盖
C.不一定要重写覆盖所有纯虚函数，编译器会自动实现默认析构函数
**5**
A.dynamic_cast<>(parameter)检查parameter是否多态，而此时p是Instrument指针，其没有虚函数，返回的是nullptr
B.static_case<>(parameter)只检查二者之间的继承关系，所以可以成功转换类型，但危险
C.static_cast可以进行任意类型之间的转换（对于自定义类，需要产生继承关系以及有合法的转换方式，对于基本数据类型可以随意转换）。dynamic_cast可以进行任何向上转换；对于向下转换，操作的对象必须包含虚函数
D.static_cast只能通过指针转换类型
**6**
A.
| 静态多态 | 动态多态 |
| ---- | ----- |
|通过函数重载与模板在编译期实现|通过继承和虚函数在运行期实现|
> 是通过指针调用虚函数来实现

D.类模板也是编译期被处理，且所有参数都必须在编译期被确定
**7**
A.函数模板只检查输入参数是否正确
D.通过<>已经将模板函数实例化，所以会对参数进行强制类型转换
**8**
A.可以继承多个，但对于其基类中数据成员、方法名和参数列表完全一样的函数，需要在派生类中重写以消除歧义
B.不能也不必。
不能：如果构造函数是虚函数，则创建对象时需要先知道VPTR，而在构造函数调用前，VPTR未初始化。
不必：构造函数的作用是提供类中成员初始化，调用时明确指定要创建对象的类型，没有必要是虚函数。
C.可以有，只是要有纯虚函数即可